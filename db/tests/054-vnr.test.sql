

-- \set ECHO queries

/* ###################################################################################################### */
\ir './_trm.sql'
-- \ir './set-signal-color.sql'
-- \ir './test-begin.sql'
-- \pset pager on
\timing off
\set filename datamill/000-first.sql
\set signal :green

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 1 }———:reset
begin transaction;
\ir '../054-vnr.sql'


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
--     partid    bigint                  generated by default as identity primary key,

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 2 }———:reset
create table VNR.datoms (
  -- doc         integer     not null references
  -- dsk
  -- dsnr
  vnr         VNR.vnr     not null,
  key         text        not null,
  atr         jsonb,      -- consider to use hstore
  stamped     boolean     not null default false,
  _vnr0       VNR.vnr     unique generated always as ( VNR.push( vnr ) ) stored,
  primary key ( vnr ) );
-- create unique index on VNR.datoms ( _vnr0 );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 3 }———:reset
create function VNR.on_before_update_datoms() returns trigger language plpgsql as $$ begin
  if ( old is not distinct from new ) then return new; end if;
  if ( old.stamped = true and new.stamped = false )
      or IMMUTABLE.record_has_changed( old, new, '{stamped,_vnr0}' ) then
    raise sqlstate 'IMM04' using message = format( 'illegal to update record %s -> %s', old, new );
    end if; return new; end; $$;

create trigger on_before_update_datoms
  before update on VNR.datoms for each row execute procedure VNR.on_before_update_datoms();

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 3 }———:reset
insert into VNR.datoms ( vnr, key, atr ) values
  ( '{1,-1}', '^foo', '{"key":1}' ),
  ( '{1}',    '^foo', '{"key":2}' ),
  ( '{1,+1}', '^foo', '{"key":3}' ),
  ( '{2}',    '^foo', '{"key":4}' );



-- #########################################################################################################

-- ---------------------------------------------------------------------------------------------------------
create function VNR.expand_vnr_for_sorting( ¶vnr VNR.vnr )
  returns VNR.vnr immutable parallel safe language plpgsql as $$
  declare
    ¶max_length integer := 20;
    ¶length     integer := coalesce( array_length( ¶vnr, 1 ), 0 );
  begin
    if ¶length > ¶max_length then
      raise sqlstate 'VNR72' using message = format(
        'vnr must not be longer than %s elements, got %s', ¶max_length, ¶vnr );
      end if;
    return array_cat( ¶vnr, array_fill( 0::float8, array[ ¶max_length - ¶length ] ) );
    end; $$;

-- ---------------------------------------------------------------------------------------------------------
create function VNR.expand_vnr_for_sorting( ¶vnr integer[] )
  returns integer[] immutable parallel safe language sql as $$
  select VNR.expand_vnr_for_sorting( ¶vnr::VNR.vnr )::integer[]; $$;

-- ---------------------------------------------------------------------------------------------------------
create function VNR.push( ¶vnr integer[] )
  returns integer[] immutable parallel safe language sql as $$
  select VNR.push( ¶vnr::VNR.vnr )::integer[]; $$;

-- ---------------------------------------------------------------------------------------------------------
create table VNR.vnr_float8 (
  nr        integer generated by default as identity primary key,
  vnr       VNR.vnr not null,
  _vnr0     VNR.vnr generated always as ( VNR.push( vnr ) ) stored,
  _vnr_long  VNR.vnr generated always as ( VNR.expand_vnr_for_sorting( vnr ) ) stored
  );

-- ---------------------------------------------------------------------------------------------------------
create table VNR.vnr_integer (
  nr        integer generated by default as identity primary key,
  vnr       integer[] not null,
  _vnr0      integer[] generated always as ( VNR.push( vnr ) ) stored,
  _vnr_long  integer[] generated always as ( VNR.expand_vnr_for_sorting( vnr ) ) stored
  );

insert into VNR.vnr_float8 ( vnr ) values
  ( array[ -1                           ] ),
  ( array[]::VNR.vnr ),
  -- ( array[ null::float8 ] ),
  ( array[ 1                            ] ),
  ( array[ 2, '-infinity'::float8       ] ),
  ( array[ 2, -9007199254740991         ] ), -- JS `Number.MIN_SAFE_INTEGER`
  ( array[ 2, -2147483648               ] ), -- PG min `integer`
  ( array[ 2, -9999999                  ] ),
  ( array[ 2                            ] ),
  ( array[ 2, 0                         ] ),
  ( array[ 2, 5e-324                    ] ), -- JS `Number.MIN_VALUE`
  ( array[ 2, 1                         ] ),
  ( array[ 2, 1, 1, 1, 1, -1            ] ),
  ( array[ 2, 1, 1, 1, 1                ] ),
  ( array[ 2, 1, 1, 1, 1, +1            ] ),
  ( array[ 2, 10, -1                    ] ),
  ( array[ 2, 10                        ] ),
  ( array[ 2, 10, 0                     ] ),
  ( array[ 2, 10, 1                     ] ),
  ( array[ 2, 100                       ] ),
  ( array[ 2, 1000                      ] ),
  ( array[ 2, +9999999                  ] ),
  ( array[ 2, +2147483648               ] ), -- PG max `integer`
  ( array[ 2, 9007199254740991          ] ), -- JS `Number.MAX_SAFE_INTEGER`
  ( array[ 2, 1.7976931348623157e+308   ] ), -- JS `Number.MAX_VALUE`
  ( array[ 2, '+infinity'::float8, -1   ] ),
  ( array[ 2, '+infinity'::float8       ] ),
  ( array[ 2, '+infinity'::float8, +1   ] );

insert into VNR.vnr_integer ( vnr ) values
  ( array[ 2, -2147483648         ] ),
  ( array[ 2, 1                   ] ),
  ( array[ 2, 1, 1, 1, 1, -1      ] ),
  ( array[ 2, 1, 1, 1, 1          ] ),
  ( array[ 2, 1, 1, 1, 1, +1      ] ),
  ( array[ 2, 10, -1              ] ),
  ( array[ 2, 10                  ] ),
  ( array[ 2, 10, 0               ] ),
  ( array[ 2, 10, 1               ] ),
  ( array[ 2, 100                 ] ),
  ( array[ 2, 1000                ] ),
  ( array[ 2, +2147483647         ] );

-- create unique index on VNR.vnr_integer using btree ( VNR.push( vnr ) );
create unique index on VNR.vnr_integer ( VNR.push( vnr ) );

select * from VNR.vnr_float8 order by vnr;
-- select * from VNR.vnr_float8 order by _vnr_long;
select * from VNR.vnr_float8 order by _vnr0;
select distinct pg_typeof( vnr ), pg_typeof( _vnr0 ), pg_typeof( _vnr_long ) from VNR.vnr_float8;
select * from VNR.datoms order by _vnr0;
update VNR.datoms set stamped = true where vnr = '{1}';
do $$
  begin
    update VNR.datoms set stamped = false where vnr = '{1}';
  exception when others then
    perform log( '^3441^', 'expected exception:', sqlerrm );
    end; $$;
select * from VNR.datoms order by _vnr0;
-- select * from VNR.vnr_float8 order by VNR.push( vnr );
-- explain analyze select * from VNR.vnr_float8 order by VNR.push( vnr );
-- select * from VNR.vnr_integer order by _vnr0;
-- select * from VNR.vnr_integer order by _vnr_long;
-- select '+infinity'::float8, '-infinity'::float8;



/* ###################################################################################################### */
\echo :red ———{ :filename 4 }———:reset
\quit



-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
select * from CATALOG.catalog where schema = 'demo';




